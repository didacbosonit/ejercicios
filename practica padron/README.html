<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Pr&aacute;ctica Hive &plus; Impala &plus; HDFS &plus; Spark</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

/* From extension ms-toolsai.jupyter */
/* These classnames are inherited from bootstrap, but are present in most notebook renderers */

.alert {
    width: auto;
    padding: 1em;
    margin-top: 1em;
    margin-bottom: 1em;
}
.alert > *:last-child {
    margin-bottom: 0;
}
#preview > .alert:last-child {
    /* Prevent this being set to zero by the default notebook stylesheet */
    padding-bottom: 1em;
}

.alert-success {
    /* Note there is no suitable color available, so we just copy "info" */
    background-color: var(--theme-info-background);
    color: var(--theme-info-foreground);
}
.alert-info {
    background-color: var(--theme-info-background);
    color: var(--theme-info-foreground);
}
.alert-warning {
    background-color: var(--theme-warning-background);
    color: var(--theme-warning-foreground);
}
.alert-danger {
    background-color: var(--theme-error-background);
    color: var(--theme-error-foreground);
}

</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="práctica-hive--impala--hdfs--spark">Práctica Hive + Impala + HDFS + Spark</h1>
<p>A partir de los datos (CSV) de Padrón de Madrid (<a href="https://datos.madrid.es/egob/catalogo/200076-1-padron.csv">https://datos.madrid.es/egob/catalogo/200076-1-padron.csv</a>) llevar a cabo lo siguiente:</p>
<h2 id="1---creación-de-tablas-en-formato-texto">1 - Creación de tablas en formato texto.</h2>
<ol>
<li>
<p>Crear Base de datos &quot;datos_padron&quot;</p>
<pre><code>CREATE DATABASE padron;
</code></pre>
</li>
<li>
<p>Crear la tabla de datos padron_txt con todos los campos del fichero CSV y cargar los datos mediante el comando LOAD DATA LOCAL INPATH. La tabla tendrá formato texto y tendrá como delimitador de campo el caracter ';' y los campos que en el documento original están encerrados en comillas dobles '&quot;' no deben estar envueltos en estos caracteres en la tabla de Hive (es importante indicar esto utilizando el serde de OpenCSV, si no la importación de las variables que hemos indicado como numéricas fracasará ya que al estar envueltos en comillas los toma como strings) y se deberá omitir la cabecera del fichero de datos al crear la tabla.</p>
<pre><code class="language-sql"><span class="hljs-keyword">set</span> hive.serdes.using.metastore.for.schema<span class="hljs-operator">=</span>org.apache.hadoop.hive.serde2.OpenCSVSerde; <span class="hljs-comment">--permite la lectura correcta con el formato de cada columna, sin este comando se convierte todo en string</span>

<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> padron_txt(
    COD_DISTRITO      <span class="hljs-type">INT</span>,
    DESC_DISTRITO     STRING,
    COD_DIST_BARRIO   <span class="hljs-type">INT</span>,
    DESC_BARRIO       STRING,
    COD_BARRIO        <span class="hljs-type">INT</span>,
    COD_DIST_SECCION  <span class="hljs-type">INT</span>,
    COD_SECCION       <span class="hljs-type">INT</span>,
    COD_EDAD_INT      <span class="hljs-type">INT</span>,
    ESPANOLESHOMBRES  <span class="hljs-type">INT</span>,
    ESPANOLESMUJERES  <span class="hljs-type">INT</span>,
    EXTRANJEROSHOMBRES <span class="hljs-type">INT</span>,
    EXTRANJEROSMUJERES <span class="hljs-type">INT</span>,
    FX_CARGA          STRING,
    FX_DATOS_INI      STRING,
    FX_DATOS_FIN      STRING
)
<span class="hljs-type">ROW</span> FORMAT SERDE <span class="hljs-string">&#x27;org.apache.hadoop.hive.serde2.OpenCSVSerde&#x27;</span>
<span class="hljs-keyword">WITH</span> SERDEPROPERTIES (
&quot;separatorChar&quot; <span class="hljs-operator">=</span> &quot;\073&quot;,
&quot;quoteChar&quot;     <span class="hljs-operator">=</span> &quot;\&quot;&quot;,
&quot;skip.header.line.count&quot; = &quot;<span class="hljs-number">1</span>&quot;
)
STORED AS TEXTFILE;

LOAD DATA LOCAL INPATH &#x27;/home/cloudera/ejercicios/padron/estadisticas202212.csv&#x27;
INTO TABLE padron_txt;
</code></pre>
<pre><code class="language-SQL"><span class="hljs-keyword">DESCRIBE</span> padron_txt;
<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> padron_txt LIMIT <span class="hljs-number">5</span>;
</code></pre>
</li>
<li>
<p>Hacer trim sobre los datos para eliminar los espacios innecesarios guardando la tabla resultado como padron_txt_2. (Este apartado se puede hacer creando la tabla con una sentencia CTAS.)</p>
<pre><code class="language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> padron_txt_2 <span class="hljs-keyword">AS</span>
<span class="hljs-keyword">SELECT</span>
COD_DISTRITO <span class="hljs-keyword">AS</span> COD_DISTRITO,
<span class="hljs-built_in">TRIM</span>(DESC_DISTRITO) <span class="hljs-keyword">AS</span> DESC_DISTRITO,
COD_DIST_BARRIO <span class="hljs-keyword">AS</span> COD_DIST_BARRIO,
<span class="hljs-built_in">TRIM</span>(DESC_BARRIO) <span class="hljs-keyword">AS</span> DESC_BARRIO,
COD_BARRIO <span class="hljs-keyword">AS</span> COD_BARRIO,
COD_DIST_SECCION <span class="hljs-keyword">AS</span> COD_DIST_SECCION,
COD_SECCION <span class="hljs-keyword">AS</span> COD_SECCION,
COD_EDAD_INT <span class="hljs-keyword">AS</span> COD_EDAD_INT,
ESPANOLESHOMBRES <span class="hljs-keyword">AS</span> ESPANOLESHOMBRES,
ESPANOLESMUJERES <span class="hljs-keyword">AS</span> ESPANOLESMUJERES,
EXTRANJEROSHOMBRES <span class="hljs-keyword">AS</span> EXTRANJEROSHOMBRES,
EXTRANJEROSMUJERES <span class="hljs-keyword">AS</span> EXTRANJEROSMUJERES,
<span class="hljs-built_in">TRIM</span>(FX_CARGA) <span class="hljs-keyword">AS</span> FX_CARGA,
<span class="hljs-built_in">TRIM</span>(FX_DATOS_INI) <span class="hljs-keyword">AS</span> FX_DATOS_INI,
<span class="hljs-built_in">TRIM</span>(FX_DATOS_FIN) <span class="hljs-keyword">AS</span> FX_DATOS_FIN
<span class="hljs-keyword">FROM</span> padron_txt;
</code></pre>
<pre><code class="language-SQL"><span class="hljs-keyword">DESCRIBE</span> padron_txt_2;
</code></pre>
<p><img src="file:///c:\Users\didac.blanco\Documents\recursos\BIG DATA\curso\practica padron\imagenes\descpad2.png" alt="descpad2"></p>
<pre><code class="language-sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> padron_txt_2 CHANGE COD_DISTRITO COD_DISTRITO <span class="hljs-type">INT</span>;
<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> padron_txt_2 CHANGE COD_DIST_BARRIO COD_DIST_BARRIO <span class="hljs-type">INT</span>;
<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> padron_txt_2 CHANGE COD_BARRIO COD_BARRIO <span class="hljs-type">INT</span>;
<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> padron_txt_2 CHANGE COD_DIST_SECCION COD_DIST_SECCION <span class="hljs-type">INT</span>;
<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> padron_txt_2 CHANGE COD_SECCION COD_SECCION <span class="hljs-type">INT</span>;
<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> padron_txt_2 CHANGE COD_EDAD_INT COD_EDAD_INT <span class="hljs-type">INT</span>;
<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> padron_txt_2 CHANGE ESPANOLESHOMBRES ESPANOLESHOMBRES <span class="hljs-type">INT</span>;
<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> padron_txt_2 CHANGE ESPANOLESMUJERES ESPANOLESMUJERES <span class="hljs-type">INT</span>;
<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> padron_txt_2 CHANGE EXTRANJEROSHOMBRES EXTRANJEROSHOMBRES <span class="hljs-type">INT</span>;
<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> padron_txt_2 CHANGE EXTRANJEROSMUJERES EXTRANJEROSMUJERES <span class="hljs-type">INT</span>;
</code></pre>
<pre><code class="language-SQL"><span class="hljs-keyword">DESCRIBE</span> padron_txt_2;
</code></pre>
<p><img src="file:///c:\Users\didac.blanco\Documents\recursos\BIG DATA\curso\practica padron\imagenes\despad2OK.png" alt="descpad2OK"></p>
</li>
<li>
<p>Investigar y entender la diferencia de incluir la palabra LOCAL en el comando LOAD DATA.</p>
<blockquote>
<p>Si utilizamos la opción 'local' en 'load data', estamos especificando la lectura en el sistema de archivos utilizado en la máquina donde se ejecuta Hive. Si no incluyes 'local', Hive asume que los datos se encuentran en HDFS y tratará de cargarlos desde allí.</p>
</blockquote>
</li>
<li>
<p>En este momento te habrás dado cuenta de un aspecto importante, los datos nulos de nuestras tablas vienen representados por un espacio vacío y no por un identificador de nulos comprensible para la tabla. Esto puede ser un problema para el tratamiento posterior de los datos. Podrías solucionar esto creando una nueva tabla utilizando sentencias case when que sustituyan espacios en blanco por 0. Para esto primero comprobaremos que solo hay espacios en blanco en las variables numéricas correspondientes a las últimas 4 variables de nuestra tabla (podemos hacerlo con alguna sentencia de HiveQL) y luego aplicaremos las sentencias case when para sustituir por 0 los espacios en blanco. (Pista: es útil darse cuenta de que un espacio vacío es un campo con longitud 0). Haz esto solo para la tabla padron_txt.</p>
<blockquote>
<p>No he podido editar la tabla existente así que he creado padron_txt_3</p>
</blockquote>
<pre><code class="language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> padron_txt_3 <span class="hljs-keyword">AS</span>
<span class="hljs-keyword">SELECT</span>
COD_DISTRITO,
DESC_DISTRITO,
COD_DIST_BARRIO,
DESC_BARRIO,
COD_BARRIO,
COD_DIST_SECCION,
COD_SECCION,
COD_EDAD_INT,
<span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> ESPANOLESHOMBRES <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-number">0</span> <span class="hljs-keyword">ELSE</span> ESPANOLESHOMBRES <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> ESPANOLESHOMBRES,
<span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> ESPANOLESMUJERES <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-number">0</span> <span class="hljs-keyword">ELSE</span> ESPANOLESMUJERES <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> ESPANOLESMUJERES,
<span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> EXTRANJEROSHOMBRES <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-number">0</span> <span class="hljs-keyword">ELSE</span> EXTRANJEROSHOMBRES <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> EXTRANJEROSHOMBRES,
<span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> EXTRANJEROSMUJERES <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-number">0</span> <span class="hljs-keyword">ELSE</span> EXTRANJEROSMUJERES <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> EXTRANJEROSMUJERES
<span class="hljs-keyword">FROM</span> padron_txt;
</code></pre>
<pre><code>ALTER TABLE padron_txt_3 CHANGE COD_DISTRITO COD_DISTRITO INT;
ALTER TABLE padron_txt_3 CHANGE COD_DIST_BARRIO COD_DIST_BARRIO INT;
ALTER TABLE padron_txt_3 CHANGE COD_BARRIO COD_BARRIO INT;
ALTER TABLE padron_txt_3 CHANGE COD_DIST_SECCION COD_DIST_SECCION INT;
ALTER TABLE padron_txt_3 CHANGE COD_SECCION COD_SECCION INT;
ALTER TABLE padron_txt_3 CHANGE COD_EDAD_INT COD_EDAD_INT INT;
ALTER TABLE padron_txt_3 CHANGE ESPANOLESHOMBRES ESPANOLESHOMBRES INT;
ALTER TABLE padron_txt_3 CHANGE ESPANOLESMUJERES ESPANOLESMUJERES INT;
ALTER TABLE padron_txt_3 CHANGE EXTRANJEROSHOMBRES EXTRANJEROSHOMBRES INT;
ALTER TABLE padron_txt_3 CHANGE EXTRANJEROSMUJERES EXTRANJEROSMUJERES INT;
</code></pre>
</li>
<li>
<p>Una manera tremendamente potente de solucionar todos los problemas previos (tanto las comillas como los campos vacíos que no son catalogados como null y los espacios innecesarios) es utilizar expresiones regulares (regex) que nos proporciona OpenCSV. Para ello utilizamos: ROW FORMAT SERDE 'org.apache.hadoop.hive.serde2.RegexSerDe' WITH SERDEPROPERTIES ('input.regex'='XXXXXXX') Donde XXXXXX representa una expresión regular que debes completar y que identifique el formato exacto con el que debemos interpretar cada una de las filas de nuestro CSV de entrada. Para ello puede ser útil el portal &quot;regex101&quot;. Utiliza este método para crear de nuevo la tabla padron_txt_2.</p>
<pre><code class="language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> padron_regex(
COD_DISTRITO      <span class="hljs-type">INT</span>,
DESC_DISTRITO     STRING,
COD_DIST_BARRIO   <span class="hljs-type">INT</span>,
DESC_BARRIO       STRING,
COD_BARRIO        <span class="hljs-type">INT</span>,
COD_DIST_SECCION  <span class="hljs-type">INT</span>,
COD_SECCION       <span class="hljs-type">INT</span>,
COD_EDAD_INT      <span class="hljs-type">INT</span>,
ESPANOLESHOMBRES  <span class="hljs-type">INT</span>,
ESPANOLESMUJERES  <span class="hljs-type">INT</span>,
EXTRANJEROSHOMBRES <span class="hljs-type">INT</span>,
EXTRANJEROSMUJERES <span class="hljs-type">INT</span>,
FX_CARGA          STRING,
FX_DATOS_INI      STRING,
FX_DATOS_FIN      STRING
)
<span class="hljs-type">ROW</span> FORMAT SERDE <span class="hljs-string">&#x27;org.apache.hadoop.hive.serde2.RegexSerDe&#x27;</span>
<span class="hljs-keyword">WITH</span> SERDEPROPERTIES(<span class="hljs-string">&#x27;input.regex&#x27;</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;^(\\d+)\\\;\\\&quot;([A-Za-z]+)\\s*\\\&quot;\\\;(\\d+)\\\;\\\&quot;([A-Za-z]+)\\s*\\\&quot;\\\;(\\d+)\\\;(\\d+)\\\;(\\d+)\\\;\\\&quot;(\\d+)\\\&quot;\\\;(\\d*)\\\;(\\d*)\\\;(\\d*)\\\;(\\d*)\\\;\\\&quot;(\\d*-\\d*-\\d*\\s\\d*:\\d*:\\d*\\d*\\.\\d*)\\&quot;\\;\\&quot;(\\d*-\\d*-\\d*)\\\&quot;\\\;\\\&quot;(\\d*-\\d*-\\d*)\\\&quot;$&#x27;</span>, &quot;skip.header.line.count&quot; <span class="hljs-operator">=</span> &quot;1&quot;);

LOAD DATA <span class="hljs-keyword">LOCAL</span> INPATH <span class="hljs-string">&#x27;/home/cloudera/ejercicios/padron/estadisticas202212.csv&#x27;</span>
<span class="hljs-keyword">INTO</span> <span class="hljs-keyword">TABLE</span> padron_regex;
</code></pre>
<p><img src="file:///c:\Users\didac.blanco\Documents\recursos\BIG DATA\curso\practica padron\imagenes\regex.png" alt="regex"></p>
</li>
</ol>
<p>Una vez finalizados todos estos apartados deberíamos tener una tabla padron_txt que conserve los espacios innecesarios, no tenga comillas envolviendo los campos y los campos nulos sean tratados como valor 0 y otra tabla padron_txt_2 sin espacios innecesarios, sin comillas envolviendo los campos y con los campos nulos como valor 0. Idealmente esta tabla ha sido creada con las regex de OpenCSV.</p>
<h2 id="2---investigamos-el-formato-columnar-parquet">2 - Investigamos el formato columnar parquet.</h2>
<ol>
<li>
<p>¿Qué es CTAS?</p>
<blockquote>
<p>CTAS (CREATE TABLE AS SELECT): es una consulta SQL que permite crear una nueva tabla en una base de datos a partir de los datos de otra tabla existente.</p>
</blockquote>
</li>
<li>
<p>Crear tabla Hive padron_parquet (cuyos datos serán almacenados en el formato columnar parquet) a través de la tabla padron_txt mediante un CTAS.</p>
<pre><code class="language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> padron_parquet
STORED <span class="hljs-keyword">AS</span> PARQUET
<span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> padron_txt;
</code></pre>
</li>
<li>
<p>Crear tabla Hive padron_parquet_2 a través de la tabla padron_txt_2 mediante un CTAS. En este punto deberíamos tener 4 tablas, 2 en txt (padron_txt y padron_txt_2, la primera con espacios innecesarios y la segunda sin espacios innecesarios) y otras dos tablas en formato parquet (padron_parquet y padron_parquet_2, la primera con espacios y la segunda sin ellos).</p>
<pre><code class="language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> padron_parquet_2
STORED <span class="hljs-keyword">AS</span> PARQUET
<span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> padron_txt_2;
</code></pre>
</li>
<li>
<p>Opcionalmente también se pueden crear las tablas directamente desde 0 (en lugar de mediante CTAS) en formato parquet igual que lo hicimos para el formato txt incluyendo la sentencia STORED AS PARQUET. Es importante para comparaciones posteriores que la tabla padron_parquet conserve los espacios innecesarios y la tabla padron_parquet_2 no los tenga. Dejo a tu elección cómo hacerlo.</p>
</li>
<li>
<p>Investigar en qué consiste el formato columnar parquet y las ventajas de trabajar con este tipo de formatos.</p>
<blockquote>
<p>ventajas del formato columnar:</p>
</blockquote>
<ol>
<li>eficiencia de almacenamiento: normalmente las columnas tienen el mismo formato y valores parecidos entre ellos</li>
<li>mayor velocidad de lectura: en las querys estilo SQL, al trabajar con columnas para filtrar, ordenar, o simplemente leer datos, el formato columnar permite no tener que leer datos innecesarios como hariamos al guardar por filas</li>
<li>mayor escalabilidad: formato escalable y compatible con entornos distribuidos</li>
</ol>
</li>
<li>
<p>Comparar el tamaño de los ficheros de los datos de las tablas padron_txt (txt), padron_txt_2 (txt pero no incluye los espacios innecesarios), padron_parquet y padron_parquet_2 (alojados en hdfs cuya ruta se puede obtener de la propiedad location de cada tabla por ejemplo haciendo &quot;show create table&quot;).</p>
<blockquote>
<p>los dos archivos correspondientes a la tabla parquet ocupan lo mismo: 1.2MB, mientras que la tabla sin procesar padron_txt ocupa 30MB, y la tabla procesada padron_txt_clean ocupa 12MB</p>
</blockquote>
</li>
</ol>
<h2 id="3---juguemos-con-impala">3 - Juguemos con Impala</h2>
<ol>
<li>
<p>¿Qué es Impala?</p>
<blockquote>
<p>Impala es una herramienta para ejecutar consultas SQL en grandes conjuntos de datos en sistemas Hadoop de manera rápida y escalable.</p>
</blockquote>
</li>
<li>
<p>¿En qué se diferencia de Hive?</p>
<ol>
<li>Hive se enfoca en consultas a gran escala con HiveQL, mientras que Impala se enfoca en consultas en tiempo real con SQL estándar.</li>
<li>Hive tiene una arquitectura basada en mapreduce, mientras que Impala tiene una arquitectura basada en máquinas.</li>
<li>Impala suele ser más rápido que Hive para consultas en tiempo real, pero Hive puede ser más adecuado para consultas a gran escala con procesamiento de mapreduce.</li>
</ol>
</li>
<li>
<p>Comando INVALIDATE METADATA, ¿en qué consiste?</p>
<blockquote>
<p>El comando INVALIDATE METADATA es un comando de Impala que se utiliza para informar al sistema de que los metadatos de una tabla o vista han cambiado y deben volver a leerse. Se puede especificar un nombre de tabla o vista para invalidar solo sus metadatos o no especificar ningún nombre para invalidar los metadatos de todas las tablas y vistas en la base de datos actual. Este comando no afecta a los datos de la tabla o vista, solo a sus metadatos, y no debe utilizarse con frecuencia para evitar impactar el rendimiento del sistema.</p>
</blockquote>
</li>
<li>
<p>Hacer invalidate metadata en Impala de la base de datos datos_padron.</p>
<pre><code class="language-sql">impala<span class="hljs-operator">-</span>shell
<span class="hljs-keyword">show</span> databases;
use datos_padron;
invalidate metadata;
</code></pre>
<p><img src="file:///c:\Users\didac.blanco\Documents\recursos\BIG DATA\curso\practica padron\imagenes\invalidate%20metadata.png" alt="invalidatemetadata"></p>
</li>
<li>
<p>Calcular el total de EspanolesHombres, espanolesMujeres,ExtranjerosHombres y ExtranjerosMujeres agrupado por DESC_DISTRITO y DESC_BARRIO.</p>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> desc_distrito, desc_barrio, <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">cast</span>(EspanolesHombres <span class="hljs-keyword">AS</span> <span class="hljs-type">int</span>)) <span class="hljs-keyword">AS</span> EspanolesHombres, <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">cast</span>(espanolesMujeres <span class="hljs-keyword">AS</span> <span class="hljs-type">int</span>)) <span class="hljs-keyword">AS</span> espanolesMujeres, <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">cast</span>(ExtranjerosHombres <span class="hljs-keyword">AS</span> <span class="hljs-type">int</span>)) <span class="hljs-keyword">AS</span> ExtranjerosHombres, <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">cast</span>(ExtranjerosMujeres <span class="hljs-keyword">AS</span> <span class="hljs-type">int</span>)) <span class="hljs-keyword">AS</span> ExtranjerosMujeres
<span class="hljs-keyword">FROM</span> padron_txt_clean
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> desc_distrito, desc_barrio;
</code></pre>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> desc_distrito, desc_barrio, <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">cast</span>(EspanolesHombres <span class="hljs-keyword">AS</span> <span class="hljs-type">int</span>)) <span class="hljs-keyword">AS</span> EspanolesHombres, <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">cast</span>(espanolesMujeres <span class="hljs-keyword">AS</span> <span class="hljs-type">int</span>)) <span class="hljs-keyword">AS</span> espanolesMujeres, <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">cast</span>(ExtranjerosHombres <span class="hljs-keyword">AS</span> <span class="hljs-type">int</span>)) <span class="hljs-keyword">AS</span> ExtranjerosHombres, <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">cast</span>(ExtranjerosMujeres <span class="hljs-keyword">AS</span> <span class="hljs-type">int</span>)) <span class="hljs-keyword">AS</span> ExtranjerosMujeres
<span class="hljs-keyword">FROM</span> padron_parquet_clean
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> desc_distrito, desc_barrio;
</code></pre>
</li>
<li>
<p>Llevar a cabo las consultas en Hive en las tablas padron_txt_2 y padron_parquet_2 (No deberían incluir espacios innecesarios). ¿Alguna conclusión?</p>
<blockquote>
<p>sobre la tabla en formato normal, hive tardó 38.2s, y con el formato parquet tardó 32.5s</p>
</blockquote>
</li>
<li>
<p>Llevar a cabo la misma consulta sobre las mismas tablas en Impala. ¿Alguna conclusión?</p>
<blockquote>
<p>sobre la tabla en formato normal, impala tardó 0.94s, y con el formato parquet tardó 0.71s</p>
</blockquote>
</li>
<li>
<p>¿Se percibe alguna diferencia de rendimiento entre Hive e Impala?</p>
<blockquote>
<p>la diferencia en tiempos de ejecución es clara</p>
</blockquote>
</li>
</ol>
<h2 id="4---sobre-tablas-particionadas">4 - Sobre tablas particionadas</h2>
<ol>
<li>Crear tabla (Hive) padron_particionado particionada por campos DESC_DISTRITO y DESC_BARRIO cuyos datos estén en formato parquet.</li>
</ol>
<pre><code class="language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> padron_particionado (
  COD_DISTRITO <span class="hljs-type">INT</span>,
  COD_DIST_BARRIO <span class="hljs-type">INT</span>,
  COD_BARRIO <span class="hljs-type">INT</span>,
  COD_DIST_SECCION <span class="hljs-type">INT</span>,
  COD_SECCION <span class="hljs-type">INT</span>,
  COD_EDAD_INT <span class="hljs-type">INT</span>,
  ESPANOLESHOMBRES <span class="hljs-type">INT</span>,
  ESPANOLESMUJERES <span class="hljs-type">INT</span>,
  EXTRANJEROSHOMBRES <span class="hljs-type">INT</span>,
  EXTRANJEROSMUJERES <span class="hljs-type">INT</span>,
  FX_CARGA STRING,
  FX_DATOS_INI STRING,
  FX_DATOS_FIN STRING
)
PARTITIONED <span class="hljs-keyword">BY</span> (DESC_DISTRITO STRING, DESC_BARRIO STRING)
<span class="hljs-type">ROW</span> FORMAT SERDE <span class="hljs-string">&#x27;org.apache.hadoop.hive.serde2.OpenCSVSerde&#x27;</span>
<span class="hljs-keyword">WITH</span> SERDEPROPERTIES (
   &quot;separatorChar&quot; <span class="hljs-operator">=</span> &quot;\073&quot;,
   &quot;quoteChar&quot;     <span class="hljs-operator">=</span> &quot;\&quot;&quot;,
   &quot;skip.header.line.count&quot; = &quot;<span class="hljs-number">1</span>&quot;
)
STORED AS PARQUET;
</code></pre>
<ol start="2">
<li>
<p>Insertar datos (en cada partición) dinámicamente (con Hive) en la tabla recién creada a partir de un select de la tabla padron_parquet_2.</p>
<pre><code class="language-sql"><span class="hljs-keyword">SET</span> hive.exec.dynamic.partition<span class="hljs-operator">=</span><span class="hljs-literal">true</span>;
<span class="hljs-keyword">SET</span> hive.exec.dynamic.partition.mode<span class="hljs-operator">=</span>non<span class="hljs-operator">-</span>strict;
<span class="hljs-keyword">SET</span> hive.enforce.bucketing <span class="hljs-operator">=</span><span class="hljs-literal">true</span>;​

<span class="hljs-keyword">INSERT</span> OVERWRITE <span class="hljs-keyword">TABLE</span> padron_particionado <span class="hljs-keyword">PARTITION</span>(DESC_DISTRITO, DESC_BARRIO)
<span class="hljs-keyword">SELECT</span> COD_DISTRITO, COD_DIST_BARRIO, COD_BARRIO, COD_DIST_SECCION, COD_SECCION, COD_EDAD_INT, ESPANOLESHOMBRES, ESPANOLESMUJERES, EXTRANJEROSHOMBRES, EXTRANJEROSMUJERES, FX_CARGA, FX_DATOS_INI, FX_DATOS_FIN, DESC_DISTRITO, DESC_BARRIO <span class="hljs-keyword">from</span>  padron_parquet;
</code></pre>
</li>
<li>
<p>Hacer invalidate metadata en Impala de la base de datos padron_particionado.</p>
</li>
<li>
<p>Calcular el total de EspanolesHombres, EspanolesMujeres, ExtranjerosHombres y ExtranjerosMujeres agrupado por DESC_DISTRITO y DESC_BARRIO para los distritos CENTRO, LATINA, CHAMARTIN, TETUAN, VICALVARO y BARAJAS.</p>
</li>
<li>
<p>Llevar a cabo la consulta en Hive en las tablas padron_parquet y padron_partitionado. ¿Alguna conclusión?</p>
</li>
<li>
<p>Llevar a cabo la consulta en Impala en las tablas padron_parquet y padron_particionado. ¿Alguna conclusión?</p>
</li>
<li>
<p>Hacer consultas de agregación (Max, Min, Avg, Count) tal cual el ejemplo anterior con las 3 tablas (padron_txt_2, padron_parquet_2 y padron_particionado) y comparar rendimientos tanto en Hive como en Impala y sacar conclusiones.</p>
</li>
</ol>

        <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </body>
    </html>